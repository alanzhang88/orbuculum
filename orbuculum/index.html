<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <title>Orbuculum</title>
    <!-- This index.html file contains two shader programs that renders the crystall ball based on environment map generated from Google Streetveiw API

    Reference: http://math.hws.edu/eck/cs424/notes2013/webgl/skybox-and-reflection/skybox-and-env-map.html

    -->
    <!-- Shaders for SkyBox -->
    <script type="x-shader/x-vertex" id="vshaderBox">
        uniform mat4 projection;
        uniform mat4 modelview;
        attribute vec3 coords;
        attribute vec3 normal;
        varying vec3 vcoords;
        varying vec3 viewCoords;
        varying vec3 vNormal;
        void main() {
            vec4 eyeCoords = modelview * vec4(coords, 1.0);
            gl_Position = projection * eyeCoords;
            vcoords = coords;// normalized already
            viewCoords = vec3(eyeCoords);
            vNormal = vec3(modelview * vec4(normal,0.0));
        }
    </script>
    <script type="x-shader/x-fragment" id="fshaderBox">
        precision mediump float;
        varying vec3 vcoords;
        varying vec3 vNormal;
        varying vec3 viewCoords;
        uniform samplerCube skybox;
        uniform vec3 lightPosition;
        void main() {

             vec3 toLightNormal = normalize(lightPosition - viewCoords);
            vec3 N = normalize(-vNormal);
            float lightIntensity = 0.3 + 0.8 * max(dot(N, toLightNormal), 0.0);
            vec4 cubetex = textureCube(skybox, vcoords);
            gl_FragColor = vec4(cubetex.rgb * lightIntensity,cubetex.a);

            //gl_FragColor = vec4(vec3(0.5,0.5,0.5) * lightIntensity, 1.0);
            //gl_FragColor = textureCube(skybox, vcoords);
            //gl_FragColor = vec4(0.5,0.5,0.5,1.0);
        }
    </script>
    <!-- Shaders for Ball -->
    <script type="x-shader/x-vertex" id="vshader">
        uniform mat4 projection;
        uniform mat4 modelview;
        attribute vec3 coords;
        attribute vec3 normal;
        varying vec3 viewCoords;
        varying vec3 vNormal;
        void main() {
            vec4 eyeCoords = modelview * vec4(coords, 1.0);
            gl_Position = projection * eyeCoords;
            viewCoords = eyeCoords.xyz;
            //vNormal = normal;
            vNormal = vec3(modelview * vec4(normal,0.0));
        }
    </script>
    <script type="x-shader/x-fragment" id="fshader">
        precision mediump float;
        varying vec3 vNormal;
        varying vec3 viewCoords;
        uniform samplerCube skybox;
        uniform mat3 normalMV; // normal matrix of modelview matrix
        uniform mat3 invMV;
        uniform vec3 lightPosition;
        uniform float shininess;
        uniform int blurLen;
        // kernel
        float kernel[13];

        void main() {
            // vec3 N = normalMV * vNormal;
            // vec3 V = -viewCoords;
            // vec3 R = V - 2.0 * dot(V,N) * N;
            // R = invMV * R; // transform it back to model coordinates
            // R = normalize(R);
            // gl_FragColor = textureCube(skybox, R);

            vec3 toLightNormal = normalize(lightPosition - viewCoords);

            //vec3 N = normalize(normalMV * vNormal);
            vec3 N = normalize(vNormal);
            vec3 V = -viewCoords;
            vec3 norV = normalize(V);
            //vec3 R = -reflect(V,N);
            vec3 R = reflect(-norV,N);
            vec3 norR = normalize(R);

            vec3 Half = normalize( toLightNormal + norV );
            vec3 T = invMV * R; // Transform by inverse of the view transform that was applied to the skybox
            float spec = 4.0 * pow(max(dot(norR,norV),0.0),shininess);
            if(dot(N, toLightNormal) < 0.0)spec=0.0;
            float lightIntensity = 0.6 + 0.8 * max(dot(N, toLightNormal), 0.0);
            vec4 cubetex = vec4(0.0);
            // do blur if required
            if (blurLen > 1) {
                // prepare stuff
                vec3 v1 = vec3(0.03)*normalize(cross(T, vec3(0.0,0.0,1.0)));
                vec3 v2 = vec3(0.03)*normalize(cross(T, v1));
                int halfcnt = (blurLen - 1) / 2;
                if (blurLen == 3) {
                    kernel[0] = kernel[2] = .308758;
                    kernel[1] = .382483;
                } else if (blurLen == 5) {
                    kernel[0] = kernel[4] = .122581;
                    kernel[1] = kernel[3] = .233062;
                    kernel[2] = .288713;
                } else if (blurLen == 7) {
                    kernel[0] = kernel[6] = .038735;
                    kernel[1] = kernel[5] = .113085;
                    kernel[2] = kernel[4] = .215007;
                    kernel[3] = .266346;
                } else if (blurLen == 9) {
                    kernel[0] = kernel[8] = .008488;
                    kernel[1] = kernel[7] = .038078;
                    kernel[2] = kernel[6] = .111165;
                    kernel[3] = kernel[5] = .211357;
                    kernel[4] = .261824;
                }
                // do the convolution
                for (int i = 0; i <= 13; i++) {
                    if (i >= blurLen-1) break;
                    float s1 = float(i - halfcnt);
                    vec3 off1 = vec3(s1) * v1;
                    vec3 base = T + off1;
                    for (int j = 0; j <= 13; j++) {
                        if (j >= blurLen-1) break;
                        float s2 = float(j - halfcnt);
                        vec3 off2 = vec3(s2) * v2;
                        cubetex += kernel[j]*kernel[i] * textureCube(skybox, base + off2);
                    }
                }
            } else {
                cubetex = textureCube(skybox, T);
            }
            gl_FragColor = vec4(cubetex.rgb * lightIntensity,cubetex.a);
            //gl_FragColor = vec4(vec3(0.5,0.5,0.5)*lightIntensity,1.0);
            //gl_FragColor = cubetex;
            // gl_FragColor = vec4(vNormal.z,0,-vNormal.z, 1.0);
            // gl_FragColor = vec4(1.0,0.0,0.0,1.0);
        }
    </script>
    <script type="x-shader/x-vertex" id="vGshader"> //Gouraud shading model, assume uniform light
    precision mediump float;
    attribute vec3 coords;
    attribute vec2 texcoords;
    varying vec2 fTexCoord;
    varying vec4 VERTEX_COLOR;
    uniform mat4 projection;
    uniform mat4 modelview;
    uniform mat4 modelTrans;
    uniform vec4 shapeColor;
    uniform float ambient;

    void main() {
        vec4 eyeCoords = modelview * modelTrans * vec4(coords, 1.0);
        gl_Position = projection * eyeCoords;
        fTexCoord = texcoords;

        VERTEX_COLOR = vec4(shapeColor.xyz * ambient, shapeColor.w);
    }
    </script>
    <script type="x-shader/x-fragment" id="fGshader">
    precision mediump float;

    uniform sampler2D texture;
    uniform vec4 shapeColor;
    uniform float beta;

    varying vec4 VERTEX_COLOR;
    varying vec2 fTexCoord;

    void main() {
        vec4 tex_color = texture2D(texture, fTexCoord);
        // gl_FragColor = tex_color;
        gl_FragColor = vec4(VERTEX_COLOR.rgb, tex_color.a * beta);
        // gl_FragColor = beta * VERTEX_COLOR + (1.0 - beta) * tex_color;
    }

    </script>

	<!-- Shaders wit shadow mapping for Skybox -->
	<script type="x-shader/x-vertex" id="vshaderBoxShadow">
        uniform mat4 projection;
        uniform mat4 modelview;
        attribute vec3 coords;
		attribute vec3 normal;
        varying vec3 vcoords;
		varying vec3 vNormal;
		varying vec3 viewCoords;
        void main() {
            vec4 eyeCoords = modelview * vec4(coords, 1.0);
            gl_Position = projection * eyeCoords;
            vcoords = coords;// normalized already
			viewCoords = vec3(eyeCoords);
			//vNormal = vec3(modelview * vec4(normal,0.0));
			vNormal = normal;
        }
    </script>
    <script type="x-shader/x-fragment" id="fshaderBoxShadow">
        precision mediump float;
        varying vec3 vcoords;
		varying vec3 vNormal;
		varying vec3 viewCoords;
        uniform samplerCube skybox;
		uniform vec3 lightPosition;
		uniform samplerCube lightShadowMap;
		uniform vec2 shadowClipNearFar;

        void main() {

 			vec3 toLightNormal = normalize(lightPosition - vcoords);
			//float fromLightToFrag =
				//(length(viewCoords - lightPosition) - shadowClipNearFar.x)
				///
				//(shadowClipNearFar.y - shadowClipNearFar.x);
			vec3 WlightPosition = vec3(lightPosition.xy,(lightPosition.z+20.0));

			float fromLightToFrag =
				(length(vcoords - lightPosition) - shadowClipNearFar.x)
				/
				(shadowClipNearFar.y - shadowClipNearFar.x);

			vec3 WtoLightNormal = normalize(WlightPosition-vcoords);

			float shadowMapValue = textureCube(lightShadowMap, -toLightNormal).r;
			vec3 N = normalize(-vNormal);
			float lightIntensity = 0.3;
			if ((shadowMapValue + 0.1) >= fromLightToFrag) {
					lightIntensity += 0.8 * max(dot(N, WtoLightNormal), 0.0);
			}

			vec4 cubetex = textureCube(skybox, vcoords);
			gl_FragColor = vec4(cubetex.rgb * lightIntensity,cubetex.a);

			//gl_FragColor = vec4(vec3(1.0,1.0,1.0) * lightIntensity, 1.0);
            //gl_FragColor = textureCube(lightShadowMap, -WtoLightNormal);
			//gl_FragColor = vec4(fromLightToFrag,fromLightToFrag,fromLightToFrag,1.0);
        }
    </script>

	<script type="x-shader/x-vertex" id="vshaderBoxShadowGen">
		precision mediump float;

		uniform mat4 projection;
		uniform mat4 modelview;


		attribute vec3 coords;

		varying vec3 vcoords;

		void main()
		{
			//vcoords = vec3(modelview * vec4(coords, 1.0));
			vcoords = coords;

			gl_Position = projection * modelview * vec4(coords, 1.0);
		}
	</script>

	<script type="x-shader/x-fragment" id="fshaderBoxShadowGen">
		precision mediump float;

		uniform vec3 lightPosition;
		uniform vec2 shadowClipNearFar;

		varying vec3 vcoords;

		void main()
		{
			vec3 fromLightToFrag = (vcoords - lightPosition);
			//vec3 fromLightToFrag = (vcoords - vec3(lightPosition.xy,(lightPosition.z+20.0)));

			float lightFragDist =
				(length(fromLightToFrag) - shadowClipNearFar.x)
				/
				(shadowClipNearFar.y - shadowClipNearFar.x);

			gl_FragColor = vec4(lightFragDist, lightFragDist, lightFragDist, 1.0);
		}
	</script>

    <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <h1>Orbuculum <span id="not_really">not really, more like "mirror ball"</span></h1>
        <div class="browser-landing" id="main">
            <div class="compact marquee">
                <div id="info">
                <p id="info_start">
                    Tell me the place you wanna see...
                </p>
                <p id="info_speak_now" class="info-text">
                    Speak now.
                </p>
                <p id="info_no_speech" class="info-text">
                    No speech was detected. You may need to adjust your
                    settings</a>.
                </p>
                <p id="info_no_microphone" class="info-text">
                    No microphone was found. Ensure that a microphone is installed and that
                    microphone settings</a> are configured correctly.
                </p>
                <p id="info_allow" class="info-text">
                    Click the "Allow" button above to enable your microphone.
                </p>
                <p id="info_denied" class="info-text">
                    Permission to use microphone was denied.
                </p>
                <p id="info_blocked" class="info-text">
                    Permission to use microphone is blocked. To change, go to
                    chrome://settings/contentExceptions#media-stream
                </p>
                <p id="info_upgrade" class="info-text">
                    Web Speech API is not supported by this browser.
                    Please consider latest Chrome.
                </p>
                </div>
                <div class="voice-wrapper">
                    <div id="results" class="voice-text card">
                        <span class="final" id="final_span"></span>
                        <span class="interim" id="interim_span"></span>
                    </div>
                    <div id="div_start">
                        <button id="start_button" class="card"
                            onclick="startButton(event)">
                            <img alt="Start" id="start_img" src="image/mic.gif">
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <main>
            <section class="canvas-wrapper">
                <canvas width="600" height="400" id="glcanvas"></canvas>
                <p id="message"></p>
            </section>
            <section class="map-wrapper">
                <div id="map" tabindex="0"></div>
                <div id="pac-container">
                    <input id="pac-input" class="card"
                     type="text" placeholder="Enter a location" >
                </div>
            </section>
        </main>

        <script
        src="https://code.jquery.com/jquery-3.1.1.min.js"
        integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
        crossorigin="anonymous"></script>
        <script type="text/javascript" src="lib/webgl-debug.js"></script>
        <script type="text/javascript" src="lib/gl-matrix-min.js"></script>
        <script type="text/javascript" src="lib/objects.js"></script>
        <script type="text/javascript" src="lib/utils.js"></script>
        <script type="text/javascript" src="lib/simple-rotator.js"></script>
        <script type="text/javascript" src="lib/retrieve-img.js"></script>
        <script type="text/javascript" src="lib/StackBlur.js"></script>
        <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCCSIanF_npOtptuVIacA2WBfJ3dADCJDM&libraries=places"></script>
        <script type="text/javascript" src="main.js"></script>
        <script src="lib/voice.js"></script>
    </body>
</html>